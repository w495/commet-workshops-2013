(*****************************************************************************
 *
 *  @mainpage Умножение матриц.
 *
 *  @section ОПИСАНИЕ
 *      Считывает со стандартного ввода 2 матрицы. Строки матриц 
 *      отделены переводом строки, числа в строке пробелами.
 *      Выводит на стандартный вывод произведение этих двух матриц
 *      в таком же формате.
 *      При запуске программы на вход (со стандартного ввода) подается матрицы:
 *          * каждая строка отделена переводом стоки;
 *          * число в одной строке отделены пробелами;
 *          * в текущей реализации матрицы используются квадратные;
 *          * размерность матрицы определяется константой MAXRANGE;
 *          * после умножения результат подается на стандартный вывод:
 *              * каждая строка отделена переводом стоки,
 *              * число в одной строке отделены пробелами.
 *      Консольный запуск программы для подсчета произведения матрицы
 *          (1, 2)  на  (1, 2)
 *          (3, 4)      (3, 4)
 *      имеет вид:
 *          |$> ./ws03_matrix_1         |
 *          |1 2                        |
 *          |3 4                        |
 *          |                           |
 *          |1 2                        |
 *          |3 4                        |
 *          |                           |
 *          |7 10                       |
 *          |15 22                      |
 *
 *      @subsection ЗАДАЧА
 *          Требуется считать 2 матрицы заданного размера со стандартного
 *          ввода. Умножить их, и результат умножения вывести на экран.
 *
 *      @subsection АЛГОРИТМ
 *          Пусть даны 2 матрицы (которые ввел пользователь):
 *          A и B, C — произведение этих матриц.
 *
 *              A * B =
 *                      (A[1][1], ..., A[1][s])   (B[1][1], ..., B[1][m])
 *                  =   (         ...         ) * (         ...         ) =
 *                      (A[n][1], ..., A[n][s])   (B[s][1], ..., B[s][m])
 * 
 *                          (C[1][1], ..., C[1][m])
 *                      =   (         ...         ) = С;
 *                          (C[n][1], ..., C[n][m])
 *
 *          Где,
 *              C[1][1] = A[1][1]*B[1][1] + ... + A[1][s]*B[s][1];
 *              C[1][2] = A[1][1]*B[1][2] + ... + A[1][s]*B[s][2];
 *                    ...        ...        ...        ...
 *              C[n][m] = A[n][1]*B[1][m] + ... + A[n][s]*B[s][m].
 *          Т.о.
 *              C[i][j] = ∑(A[i][k]*B[k][j]).
 *
 *  @section ЛИЦЕНЗИЯ (MIT\MAI)
 *      © 2013 КО-101С, кафедра 806, МАИ, «Комета»
 *      Данная лицензия разрешает лицам, получившим копию данного
 *      программного обеспечения и сопутствующей документации,
 *      в дальнейшем именуемыми «Программное Обеспечение»,
 *      безвозмездно использовать Программное Обеспечение без ограничений
 *      на территории РФ, включая неограниченное право на использование,
 *      копирование, изменение, добавление, публикацию, распространение,
 *      сублицензирование и/или продажу копий Программного Обеспечения,
 *      также как и лицам, которым предоставляется данное
 *      Программное Обеспечение, при соблюдении следующих условий:
 *          Указанное выше уведомление об авторском праве
 *          и данные условия должны быть включены во все копии
 *          или значимые части данного Программного Обеспечения.
 *      Данное программное обеспечение предоставляется «как есть»,
 *      без каких-либо гарантий, явно выраженных или подразумеваемых,
 *      включая, но не ограничиваясь гарантиями товарной пригодности,
 *      соответствия по его конкретному назначению и отсутствия нарушений прав.
 *      ни в каком случае авторы или правообладатели не несут ответственности
 *      по искам о возмещении ущерба, убытков или других требований
 *      по действующим контрактам, деликтам или иному, возникшим из,
 *      имеющим причиной или связанным с программным обеспечением
 *      или использованием программного обеспечения
 *      или иными действиями с программным обеспечением.
 *
 *  @file ws03_matrix_1.pas
 *      Основной файл программы, именно его и нужно компилировать.
 *
 *  @package ws03_matrix_1
 *      Основной модуль программы, умножения матриц.
 *
 *  @author     Кирпичев Александр,
 *              Cуворов Михаил,
 *              Оганезова Валерия,
 *              Илья w-495 Никитин <w@w-495.ru> 
 *                  (из КО-101С,  кафедра 806, МАИ, «Комета»)
 *  @date       2013.03.26 17:57:00
 *  @version    1.1
 *
 *****************************************************************************)

program ws03_matrix_1;

(*****************************************************************************
                ОБЪЯВЛЕНИЯ КОНСТАНТ И ТИПОВ
 *****************************************************************************)

(**
    @const MAXRANGE Максимальный возможный размер вектора
**)
const MAXRANGE = 2;

(**
    @type   size_t  тип индексов массивов и матриц
            Определяем как отдельный тип,
            на случай, если вдруг, размерности не хватит 
            и его придется заменить. Например на `longint`.
    type size_t  = longint; 
**)
type size_t  = byte;

(**
    @type   contents_t  тип содержимого матрицы.
            Определяем как отдельный тип,
            на случай, если вдруг придется его заменить.
            Например на `real`.
    type contents_t  = real;
**)
type contents_t  = longint;

(**
    @type   array_t  тип массива из contents_t
**)
type array_t  = array[1..MAXRANGE] of contents_t;

(**
    @type   matrix_t  тип матрицы — массив из массивов
**)
type matrix_t  = array[1..MAXRANGE] of array_t;

(*  --[Подсказка]-------------------------------------------------------------
    Существует альтернативный способ задать матрицу:
        type matrix_t  = array[1..MAXRANGE, 1..MAXRANGE] of contents_t;
    В этом случае нет необходимости вводить тип массива.
    Но он не работает в PascalABC.
    --------------------------------------------------------------------------
*)

(*****************************************************************************
                ОПИСАНИЕ ФУНКЦИЙ И ПРОЦЕДУР
 *****************************************************************************)

(**
    @fn readmatrix
        Считывает матрицу размером `nrows`, `ncolumns` со стандартного ввода
        и возвращает ее.
    @param nrows    число строк входной матрицы;
    @param ncolumns число столбцов входной матрицы.
**)
function readmatrix(nrows, ncolumns :size_t): matrix_t;
    (*  --[Подсказка]---------------------------------------------------------
        Выражение эквивалентно:
            function readmatrix(nrows: size_t; ncolumns : size_t): matrix_t;
        Но первый вариант короче!
        ----------------------------------------------------------------------
    *)
    var row,                (** номер строки  **)
        column: size_t;     (** номер столбца **)
    var result: matrix_t;   (** входная матрица **)
    begin
        for row := 1 to nrows do
        begin
            for column := 1 to ncolumns do
                read(result[row][column]);
        end;
        writeln();
        readmatrix := result;
    end;

(**
    @fn writematrix
        Выводит матрицу `matrix` размером `nrows`, `ncolumns` 
        на стандартный вывод.
    @param matrix   выходная матрица;
    @param nrows    число строк выходной матрицы;
    @param ncolumns число столбцов выходной матрицы.
**)
procedure writematrix(matrix :matrix_t; nrows, ncolumns :size_t);
    (*  --[Подсказка]---------------------------------------------------------
        Выражение эквивалентно:
            function writematrix(
                matrix: matrix_t;
                nrows: size_t;
                ncolumns : size_t
            ): matrix_t;
        Но первый вариант короче!
        ----------------------------------------------------------------------
    *)
    var row,            (** номер строки  **)
        column: size_t; (** номер столбца **)
    begin
        for row := 1 to nrows do
        begin
            for column := 1 to ncolumns do
                write(matrix[row][column], ' ');
            writeln();
        end;
    end;

(**
    @fn multmatrix
        Перемножает 2 матрицы A(n,s) и B(s, m)
        и возвращает результат умножения матрицу C(n, m).

        (A[1][1], A[1][2], ..., A[1][s])   (B[1][1], B[1][2], ..., B[1][m])
        (                  ...         ) * (                  ...         ) =
        (A[n][1], A[n][2], ..., A[n][s])   (B[s][1], B[s][2], ..., B[s][m])
                
                (C[1][1], C[1][2], ..., C[1][m])
            =   (                  ...         );
                (C[n][1], C[n][2], ..., C[n][m])
        Где,
            C[1][1] = A[1][1]*B[1][1] + ... + A[1][s]*B[s][1];
            C[1][2] = A[1][1]*B[1][2] + ... + A[1][s]*B[s][2];
                  ...        ...        ...        ...
            C[n][m] = A[n][1]*B[1][m] + ... + A[n][s]*B[s][m].
        Т.о.
            C[i][j] = ∑(A[i][k]*B[k][j]).
    @param A            первая матрица для перемножения;
    @param B            вторая матрица для перемножения;
    @param nrows        число строк выходной матрицы (n);
    @param ncolumns     число столбцов выходной матрицы (m);
    @param ncouplings   число столбцов матрицы A и число строк матрицы B (s).
**)
function multmatrix(
    A, B        :matrix_t;
    nrows,
    ncolumns,
    ncouplings  :size_t
): matrix_t;
    (*  --[Подсказка]---------------------------------------------------------
        Выражение эквивалентно:
            function multmatrix(
                A   :matrix_t;
                B   :matrix_t;
                nrows       :size_t;
                ncolumns    :size_t;
                ncouplings  :size_t
            ): matrix_t;
        Но первый вариант короче!
        ----------------------------------------------------------------------
    *)
    var C: matrix_t;        (** выходная матрица **)
    var row,                (** номер строки выходной матрицы  **)
        column,             (** номер столбца выходной матрицы **)
        coupling: size_t;   (** номер столбца матрицы A и строки матрицы B **)
    begin
        for row := 1 to nrows do
            for column := 1 to ncolumns do
            begin
                (**
                    Присваиваем нулю, т.к. ячейка матрицы не инициализирована.
                    Кроме того, это позволяет нам в общем виде собирать сумму.
                **)
                C[row][column] := 0;
                for coupling := 1 to ncouplings do
                    C[row][column] :=
                        A[row][coupling]*B[coupling][column]
                            + C[row][column];
            end;
        multmatrix := C;
    end;

(**
    @fn main 
        Производит все вычисления, собранные вместе.
        Основная процедура программы.
        Выделение кода программы из основного блока 
        в отдельную процедуру полезен тем,
        что позволяет независимо использовать переменные.
        Так мы избавляемся от глобальных переменных,
        и используем только локальные переменные процедуры.
            1) Не запутаемся в большой программе что есть, что.
            2) Не будет пересечения пространств имен.
            3) Проще искать ошибки.
**)
procedure main;
    var A       : matrix_t; (** первая входная матрица  **)
    var B       : matrix_t; (** вторая входная матрица  **)
    var C       : matrix_t; (** выходная матрица        **)
    begin
        (** cчитываем первую матрицу **)
        A := readmatrix(MAXRANGE, MAXRANGE);
        (** cчитываем вторую матрицу **)
        B := readmatrix(MAXRANGE, MAXRANGE);
        (** умножаем 2 матрицы **)
        C := multmatrix(A, B, MAXRANGE, MAXRANGE, MAXRANGE);
        (** Выводим матрицу C **)
        writematrix(C, MAXRANGE, MAXRANGE);
    end;

(**
    В основном блоке программы происходит только вызов процедуры `main`.
**)
begin
    main();
end.

