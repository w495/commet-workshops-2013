(*****************************************************************************
 *
 *  @mainpage Числа Фибоначчи. Рабочая версия. Функции.
 *
 *  @section ОПИСАНИЕ
 *      Выводит на экран числа Фибоначчи с первого по десятое.
 *
 *      @subsection ЗАДАЧА
 *          Требуется вывести на экран числа Фибоначчи с первого по десятое,
 *          в формате
 *              `номер` -> `число`
 *          Каждая пара (`номер`, `число`) должны быть на отдельной строке.
 *          В лабораторных работах здесь требуется указать номер лабораторной
 *          и номер варианта.
 *
 *      @subsection АЛГОРИТМ
 *          В цикле по вычисляем числа Фибоначчи по определению:
 *              φ(1) = 1;
 *              φ(2) = 1;
 *              φ(n) = φ(n-1) + φ(n-2), n ≥ 3.
 *
 *  @section ЛИЦЕНЗИЯ (GPL)
 *      Данная программа является свободным программным обеспечением;
 *      вы можете распространять и/или изменять его в соответствии
 *      с условиями лицензии GPL, опубликованной
 *      Free Software Foundation либо Лицензии второй версии,
 *      либо (по вашему выбору) любой более поздней версии.
 *      Эта программа распространяется в надежде, что она будет полезной,
 *      но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, даже без подразумеваемых гарантий
 *      КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНЫХ ЦЕЛЕЙ.
 *      Смотрите GNU General Public License для более подробной информации
 *      на http://www.gnu.org/copyleft/gpl.html
 *
 *  @file ws01_fib08.pas
 *      Основной файл программы, именно его и нужно компилировать.
 *
 *  @package ws01_fib08
 *      Основной модуль программы,
 *      выводит на экран числа Фибоначчи с первого по десятое.
 *      Рабочая версия программы.
 *
 *  @author     Илья w-495 Никитин <w@w-495.ru>
 *  @date       2013.02.21 13:10:01
 *  @version    0.4.0
 *
 *****************************************************************************)

program ws01_fib08;

(*****************************************************************************
                ОБЪЯВЛЕНИЯ КОНСТАНТ И ПЕРЕМЕННЫХ
 *****************************************************************************)

(**
    @const MAXRANGE Максимальный возможный номер числа Фибоначчи.
**)
const MAXRANGE = 46;

(**
    @type   fibarray_t  тип массива для чисел Фибоначчи.
            Так мы ввели новый тип.
**)
type fibarray_t  = array[1..MAXRANGE] of longint;

(**
    @var    fbr Массив с числами Фибоначчи.
            fbr ∈ fibarray_t = array[1..46] of longint;
            longint занимает 4 байта.
            Ввод массива позволяет нам работать с числами Фибоначчи
            естественно, почти как по определению.
**)
var fbr : fibarray_t;

(**
    @var    lim   Количество итераций цикла.
            Показывает, до какого предела нам нужно считать числа Фибоначчи.
            lim   ∈ byte = [0, 255];
            byte занимает 1 байт.
            ПРОБЛЕМА:
                Вводимое число не может быть больше 46.
                Из-за ограничения в curr и prev ∈ [1, 2147483647],
                числа Фибоначчи по номеру больше 46 считаются неправильно:
                происходит целочисленное переполнение.
                Решить проблему можно введя явную проверку в программе.
                Такого рода проверки называют «защитой от дурака».
**)
var lim : byte;

(**
    @var    cnt Счетчик цикла
            cnt ∈ integer = [0, 255];
            byte занимает 1 байт.
**)
var cnt : byte;


(*****************************************************************************
    АЛГОРИТМИЧЕСКАЯ ЧАСТЬ ПРОГРАММЫ: ПРОЦЕДУРЫ И ФУНКЦИИ
 *****************************************************************************)

(**
    @fn fibar
        Функция вычисления чисел Фибоначчи.
        @param  limit   :byte
            передел вычисления, максимальное число которое нам нужно.
        @return fibar   :fibarray_t
            массив чисел Фибоначчи до указанного  предела `limit`,
                если limit ∈ [1, 46];
            массив с первым элементом -1,
                если limit ∉ [1, 46];
**)

function fibar(limit :byte) : fibarray_t;
    (**
        @var    counter Счетчик цикла внутри функции.
                counter ∈ integer = [0, 255];
                byte занимает 1 байт.
    **)
    var counter :byte;
    begin
        (**
            Умный в гору не пойдет — умный гору обойдет.
            Мы не можем вычислять числа Фибоначчи с номером больше чем 46.
            Но, мы можем сделать явную проверку,
            чтобы предотвратить такой случай.

            Делаем хитрый ход — в первый элемент массива
            кладем отрицательное число.
            Мы знаем, что числа Фибоначчи всегда положительны,
            и если в результате функции мы увидим первый элемент
            массива отрицательное число, то «будем знать»,
            что мы вышли из допустимого диапазона.
            «Будем знать» всегда нужно оговаривать отдельно.
        **)
        if ((1 > limit) or (limit > 46)) then
            fibar[1] := -1
        else begin
            (**
                Присваиваем предыдущему значению 1.
            **)
            fibar[1] := 1;
            (**
                Присваиваем текущему значению 1.
            **)
            fibar[2] := 1;
            (**
                В цикле присваиваем текущей ячейке массива сумму предыдущего
                и пред-предыдущего элемента. Получается, как по определению
                    φ(n) = φ(n-1) + φ(n-2), n ≥ 3.
                Мы смогли отказаться от `prev` и `curr` потому, что их роль выполняют
                соответствующие ячейки массива. А от `temp` мы смогли отказаться,
                т.к. нет необходимости хранить старое значение `curr`.
                Мы его получаем на следующей итерации автоматически.
                Новое значение `curr`   это fibar[counter];
                Старое значение `curr`  это fibar[counter-1];
                Старое значение `prev`  это fibar[counter-2];
                А Новое значение `prev` это fibar[counter-1];
            **)
            for counter := 3 to limit do begin
                fibar[counter] := fibar[counter-1] + fibar[counter-2];
            end
        end {if}
    end;

(*****************************************************************************
    АЛГОРИТМИЧЕСКАЯ ЧАСТЬ ПРОГРАММЫ: ОСНОВНОЙ БЛОК
 *****************************************************************************)

begin
    (**
        Считываем число из входного потока,
        и кладем его в переменную `limit`.
    **)
    readln(lim);
    (**
        Вызываем функцию `fibar`. 
        Передаем ей в качестве параметра число `lim`.
        Результат вычисления присваиваем массиву `fbr`.
    **)
    fbr := fibar(lim);
    (**
        В цикле выводим очередную пару (`номер`, `число`).
    **)
    for cnt := 1 to lim do
        writeln(cnt, ' ->  ', fbr[cnt]);
end.


