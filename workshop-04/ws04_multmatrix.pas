(*****************************************************************************
 *
 *  @mainpage Умножение матриц. Структуры.
 *
 *  @section ОПИСАНИЕ
 *      Считывает со стандартного ввода 2 матрицы. 
 *      Сначала считывает размерность матриц.
 *      Строки матриц отделены переводом строки, числа в строке пробелами.
 *      Выводит на стандартный вывод произведение этих двух матриц
 *      в таком же формате. Если невозможно вычислить произведение матриц, 
 *      то выводится соответствующая ошибка.
 *      При запуске программы на вход (со стандартного ввода) подается матрицы:
 *          * каждая строка отделена переводом стоки;
 *          * число в одной строке отделены пробелами;
 *          * в текущей реализации матрицы используются квадратные;
 *          * размерность матрицы определяется константой MAXRANGE;
 *          * после умножения результат подается на стандартный вывод:
 *              * каждая строка отделена переводом стоки,
 *              * число в одной строке отделены пробелами.
 *      Консольный запуск программы для подсчета произведения матрицы
 *          〈1, 2〉  на  〈1, 2〉
 *          〈3, 4〉      〈3, 4〉
 *      имеет вид:
 *          |$> ./ws04_multmatrix 
 *          |2 2    <--{пометка: размерность}
 *          |1 2    <--{пометка: сама матрица}
 *          |3 4
 *          |
 *          |2 2    <--{пометка: размерность}
 *          |1 2    <--{пометка: сама матрица}
 *          |3 4
 *          |
 *          |7 10 
 *          |15 22 
 *          |$> ./ws04_multmatrix 
 *          |1 2    <--{пометка: размерность}
 *          |1 2    <--{пометка: сама матрица}
 *          |
 *          |2 1    <--{пометка: размерность}
 *          |1      <--{пометка: сама матрица}
 *          |2
 *          |
 *          |5 
 *          |$> ./ws04_multmatrix 
 *          |1 2    <--{пометка: размерность, несовместимы}
 *          |1 2    <--{пометка: сама матрица}
 *          |
 *          |1 2    <--{пометка: размерность, несовместимы}
 *          |1 2    <--{пометка: сама матрица}
 *          |ERROR: A.ncolumns =/= B.nrows !
 *          |$> 
 *
 *      @subsection ЗАДАЧА
 *          Требуется считать 2 матрицы заданного размера со стандартного
 *          ввода. Умножить их, и результат умножения вывести на экран.
 *          Размеренности матриц тоже считывать с клавиатуры.
 *
 *      @subsection АЛГОРИТМ
 *          Пусть даны 2 матрицы (которые ввел пользователь):
 *          A и B, C — произведение этих матриц.
 *
 *              A × B =
 *                      〈A[1][1], ..., A[1][s]〉   〈B[1][1], ..., B[1][m]〉
 *                  =   〈         ...         〉 × 〈         ...         〉 =
 *                      〈A[n][1], ..., A[n][s]〉   〈B[s][1], ..., B[s][m]〉
 * 
 *                          〈C[1][1], ..., C[1][m]〉
 *                      =   〈         ...         〉 = С;
 *                          〈C[n][1], ..., C[n][m]〉
 *
 *          Где,
 *              C[1][1] = A[1][1]×B[1][1] + ... + A[1][s]×B[s][1];
 *              C[1][2] = A[1][1]×B[1][2] + ... + A[1][s]×B[s][2];
 *                    ...        ...        ...        ...
 *              C[n][m] = A[n][1]×B[1][m] + ... + A[n][s]×B[s][m].
 *          Т.о.
 *              C[i][j] = ∑(A[i][k]×B[k][j]).
 *
 *  @section ЛИЦЕНЗИЯ (MIT\MAI)
 *      © 2013 КО-101С, кафедра 806, МАИ, «Комета»
 *      Данная лицензия разрешает лицам, получившим копию данного
 *      программного обеспечения и сопутствующей документации,
 *      в дальнейшем именуемыми «Программное Обеспечение»,
 *      безвозмездно использовать Программное Обеспечение без ограничений
 *      на территории РФ, включая неограниченное право на использование,
 *      копирование, изменение, добавление, публикацию, распространение,
 *      сублицензирование и/или продажу копий Программного Обеспечения,
 *      также как и лицам, которым предоставляется данное
 *      Программное Обеспечение, при соблюдении следующих условий:
 *          Указанное выше уведомление об авторском праве
 *          и данные условия должны быть включены во все копии
 *          или значимые части данного Программного Обеспечения.
 *      Данное программное обеспечение предоставляется «как есть»,
 *      без каких-либо гарантий, явно выраженных или подразумеваемых,
 *      включая, но не ограничиваясь гарантиями товарной пригодности,
 *      соответствия по его конкретному назначению и отсутствия нарушений прав.
 *      ни в каком случае авторы или правообладатели не несут ответственности
 *      по искам о возмещении ущерба, убытков или других требований
 *      по действующим контрактам, деликтам или иному, возникшим из,
 *      имеющим причиной или связанным с программным обеспечением
 *      или использованием программного обеспечения
 *      или иными действиями с программным обеспечением.
 *
 *  @file ws04_multmatrix.pas
 *      Основной файл программы, именно его и нужно компилировать.
 *
 *  @package ws04_multmatrix
 *      Основной модуль программы, умножения матриц.
 *
 *  @author     Кирпичев Александр,
 *              Cуворов Михаил,
 *              Илья w-495 Никитин <w@w-495.ru> 
 *                  (из КО-101С,  кафедра 806, МАИ, «Комета»)
 *  @date       2013.04.30 17:57:10
 *  @version    2.1
 *
 *****************************************************************************)

program ws04_multmatrix;

(*****************************************************************************
                ОБЪЯВЛЕНИЯ КОНСТАНТ И ТИПОВ
 *****************************************************************************)

(**
    @const MAXRANGE максимальный возможный размер вектора.
**)
const MAXRANGE = 128;

(**
    @type   size_t  тип индексов массивов и матриц
            Определяем как отдельный тип,
            на случай, если вдруг, размерности не хватит 
            и его придется заменить. Например на `longint.
    type size_t  = longint; 
**)
type size_t  = word;

(**
    @type   cell_t  тип содержимого матрицы.
            Определяем как отдельный тип,
            на случай, если вдруг придется его заменить.
            Например на `real`.
    type cell_t  = real;
**)
type cell_t  = longint;


(**
    @type   array_t  тип массива из `cell_t`.
**)
type array_t  = array[1..MAXRANGE] of cell_t;

(**
    @type   array_t  тип массива из `cell_t`.
**)
type matrixcontent_t  = array[1..MAXRANGE] of array_t;

(**
    @type   matrix_t   тип матрицы — содержимое и размерность.
**)
type matrix_t = record
    (**
        @field  content содержимое матрицы.
    **)
    content     :matrixcontent_t;
    (**
        @field  nrows   количество строк.
    **)
    nrows       :size_t;
    (**
        @field  nrows   количество столбцов.
    **)
    ncolumns    :size_t;
    (**
        @field  флаг правильность матрицы, на случай невозможности умножения.
    **)
    isvalid     :boolean;
end;

(*****************************************************************************
                ОПИСАНИЕ ФУНКЦИЙ И ПРОЦЕДУР
 *****************************************************************************)

(**
    @fn matrix_read 
        Считывает матрицу размером `nrows`, `ncolumns` со стандартного ввода
        и возвращает ее.
**)
function matrix_read(): matrix_t;
    var row,                (** номер строки  **)
        column: size_t;     (** номер столбца **)
    var result: matrix_t;   (** входная матрица **)
    begin
        (** считали количество строк матрицы **)
        read(result.nrows);
        (** считали количество столбцов матрицы **)
        read(result.ncolumns);
        for row := 1 to result.nrows do
            for column := 1 to result.ncolumns do
                read(result.content[row][column]);
        result.isvalid := true;
        matrix_read := result;
    end;

(**
    @fn matrix_write    Выводит матрицу matrix размером nrows, 
                        ncolumns на стандартный вывод.
    @param matrix   выходная матрица;.
**)
procedure matrix_write(matrix :matrix_t);
    var row,                (** номер строки  **)
        column :size_t;     (** номер столбца **)
    begin
        for row := 1 to matrix.nrows do
        begin
            for column := 1 to matrix.ncolumns do
                write(matrix.content[row][column], ' ');
            writeln();
        end;
    end;

(**
    @fn matrix_mult Перемножает 2 матрицы A(n,s) и B(s, m)
        и возвращает результат умножения матрицу C(n, m).

        〈A[1][1], A[1][2], ..., A[1][s]〉   〈B[1][1], B[1][2], ..., B[1][m]〉
        〈                  ...         〉 × 〈                  ...         〉 =
        〈A[n][1], A[n][2], ..., A[n][s]〉   〈B[s][1], B[s][2], ..., B[s][m]〉
                
                〈C[1][1], C[1][2], ..., C[1][m]〉
            =   〈                  ...         〉;
                〈C[n][1], C[n][2], ..., C[n][m]〉
        Где,
            C[1][1] = A[1][1]×B[1][1] + ... + A[1][s]×B[s][1];
            C[1][2] = A[1][1]×B[1][2] + ... + A[1][s]×B[s][2];
                  ...        ...        ...        ...
            C[n][m] = A[n][1]×B[1][m] + ... + A[n][s]×B[s][m].
        Т.о.
            C[i][j] = ∑(A[i][k]×B[k][j]).
    @param A            первая матрица для перемножения;
    @param B            вторая матрица для перемножения;
**)
function matrix_mult(A, B :matrix_t) :matrix_t;
    (*  --[Подсказка]---------------------------------------------------------
        Выражение эквивалентно:
            function matrix_mult(A :matrix_t; B :matrix_t): matrix_t;
        Но первый вариант короче!
        ----------------------------------------------------------------------
    *)
    var C: matrix_t;        (** выходная матрица **)
    var row,                (** номер строки выходной матрицы  **)
        column,             (** номер столбца выходной матрицы **)
        coupling: size_t;   (** номер столбца матрицы A и строки матрицы B **)
    begin
        (** 
            Проверяем совместимость матриц.
        **)
        if(A.ncolumns = B.nrows) then
        begin
            C.nrows := A.nrows;
            C.ncolumns := B.ncolumns;
            for row := 1 to C.nrows do
                for column := 1 to C.ncolumns do
                begin
                    (**
                        Присваиваем нулю, т.к. ячейка матрицы 
                        не инициализирована. Кроме того, это позволяет 
                        нам в общем виде собирать сумму.
                    **)
                    C.content[row][column] := 0;
                    for coupling := 1 to B.nrows do
                        C.content[row][column] :=
                            A.content[row][coupling] 
                                * B.content[coupling][column]
                                    + C.content[row][column];
                end;
            (** 
                Если A и B --- правильные матрицы, то и С правильная.
                Если хотя бы одна из них не правильная 
                (получена в результате умножения несовместных матриц), 
                то С тоже не правильная.
            **)
            C.isvalid := A.isvalid and B.isvalid;
        end
        else
        begin
            (** 
                Если A и B оказались несовместимы, то С мы посчитать не можем.
                Возвращенная матрица будет не правильной.
            **)
            C.isvalid := false;
        end;
        matrix_mult := C;
    end;

(**
    @fn main Производит все вычисления, собранные вместе.
        Основная процедура программы.
        Выделение кода программы из основного блока 
        в отдельную процедуру полезен тем,
        что позволяет независимо использовать переменные.
        Так мы избавляемся от глобальных переменных,
        и используем только локальные переменные процедуры.
            1) Не запутаемся в большой программе что есть, что.
            2) Не будет пересечения пространств имен.
            3) Проще искать ошибки.
**)
procedure main(fiction: boolean);
    var A       : matrix_t; (** первая входная матрица  **)
    var B       : matrix_t; (** вторая входная матрица  **)
    var C       : matrix_t; (** выходная матрица        **)
    begin
        A := matrix_read();
        B := matrix_read();
        C := matrix_mult(A, B);
        if(C.isvalid) then
        begin
            writeln();
            matrix_write(C);  
        end
        else
        begin
            writeln();
            writeln('ERROR: A.ncolumns =/= B.nrows !');
        end
    end;
(**
    В основном блоке программы происходит только вызов процедуры `main`.
**)
begin
    main();
end.


